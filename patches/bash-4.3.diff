			     BASH PATCH REPORT
			     =================

Bash-Release:	4.3
Patch-ID:	bash43-001

Bug-Reported-by:	NBaH <nbah@sfr.fr>
Bug-Reference-ID:	<ler0b5$iu9$1@speranza.aioe.org>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2014-02/msg00092.html

Bug-Description:

A missing check for a valid option prevented `test -R' from working.  There
is another problem that causes bash to look up the wrong variable name when
processing the argument to `test -R'.

Patch (apply with `patch -p0'):

*** ../bash-4.3/test.c	2014-02-04 16:52:58.000000000 -0500
--- test.c	2014-02-28 21:22:44.000000000 -0500
***************
*** 647,652 ****
  
      case 'R':
!       v = find_variable (arg);
!       return (v && invisible_p (v) == 0 && var_isset (v) && nameref_p (v) ? TRUE : FALSE);
      }
  
--- 647,652 ----
  
      case 'R':
!       v = find_variable_noref (arg);
!       return ((v && invisible_p (v) == 0 && var_isset (v) && nameref_p (v)) ? TRUE : FALSE);
      }
  
***************
*** 724,727 ****
--- 724,728 ----
      case 'u': case 'v': case 'w': case 'x': case 'z':
      case 'G': case 'L': case 'O': case 'S': case 'N':
+     case 'R':
        return (1);
      }
*** ../bash-4.3/patchlevel.h	2012-12-29 10:47:57.000000000 -0500
--- patchlevel.h	2014-03-20 20:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 0
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 1
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.3
Patch-ID:	bash43-002

Bug-Reported-by:	Moe Tunes <moetunes42@gmail.com>
Bug-Reference-ID:	<53103F49.3070100@gmail.com>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2014-02/msg00086.html

Bug-Description:

A change to save state while running the DEBUG trap caused pipelines to hang
on systems which need process group synchronization while building pipelines.

Patch (apply with `patch -p0'):

*** ../bash-4.3/trap.c	2014-02-05 10:03:21.000000000 -0500
--- trap.c	2014-02-28 09:51:43.000000000 -0500
***************
*** 921,925 ****
  
  #if defined (JOB_CONTROL)
!       save_pipeline (1);	/* XXX only provides one save level */
  #endif
  
--- 921,926 ----
  
  #if defined (JOB_CONTROL)
!       if (sig != DEBUG_TRAP)	/* run_debug_trap does this */
! 	save_pipeline (1);	/* XXX only provides one save level */
  #endif
  
***************
*** 941,945 ****
  
  #if defined (JOB_CONTROL)
!       restore_pipeline (1);
  #endif
  
--- 942,947 ----
  
  #if defined (JOB_CONTROL)
!       if (sig != DEBUG_TRAP)	/* run_debug_trap does this */
! 	restore_pipeline (1);
  #endif
  
*** ../bash-4.3/patchlevel.h	2012-12-29 10:47:57.000000000 -0500
--- patchlevel.h	2014-03-20 20:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 1
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 2
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.3
Patch-ID:	bash43-003

Bug-Reported-by:	Anatol Pomozov <anatol.pomozov@gmail.com>
Bug-Reference-ID:	<CAOMFOmXy3mT2So5GQ5F-smCVArQuAeBwZ2QKzgCtMeXJoDeYOQ@mail.gmail.com>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-readline/2014-03/msg00010.html

Bug-Description:

When in callback mode, some readline commands can cause readline to seg
fault by passing invalid contexts to callback functions.

Patch (apply with `patch -p0'):

*** ../bash-4.3/lib/readline/readline.c	2013-10-28 14:58:06.000000000 -0400
--- lib/readline/readline.c	2014-03-10 14:15:02.000000000 -0400
***************
*** 745,749 ****
  
    RL_CHECK_SIGNALS ();
!   if (r == 0)			/* success! */
      {
        _rl_keyseq_chain_dispose ();
--- 745,750 ----
  
    RL_CHECK_SIGNALS ();
!   /* We only treat values < 0 specially to simulate recursion. */
!   if (r >= 0 || (r == -1 && (cxt->flags & KSEQ_SUBSEQ) == 0))	/* success! or failure! */
      {
        _rl_keyseq_chain_dispose ();
*** ../bash-4.3/patchlevel.h	2012-12-29 10:47:57.000000000 -0500
--- patchlevel.h	2014-03-20 20:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 2
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 3
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.3
Patch-ID:	bash43-004

Bug-Reported-by:	Daan van Rossum <daan@flash.uchicago.edu>
Bug-Reference-ID:	<20140307072523.GA14250@flash.uchicago.edu>
Bug-Reference-URL:	

Bug-Description:

The `.' command in vi mode cannot undo multi-key commands beginning with
`c', `d', and `y' (command plus motion specifier).

Patch (apply with `patch -p0'):

*** ../bash-4.3/lib/readline/readline.c	2013-10-28 14:58:06.000000000 -0400
--- lib/readline/readline.c	2014-03-07 15:20:33.000000000 -0500
***************
*** 965,969 ****
    if (rl_editing_mode == vi_mode && _rl_keymap == vi_movement_keymap &&
        key != ANYOTHERKEY &&
!       rl_key_sequence_length == 1 &&	/* XXX */
        _rl_vi_textmod_command (key))
      _rl_vi_set_last (key, rl_numeric_arg, rl_arg_sign);
--- 965,969 ----
    if (rl_editing_mode == vi_mode && _rl_keymap == vi_movement_keymap &&
        key != ANYOTHERKEY &&
!       _rl_dispatching_keymap == vi_movement_keymap &&
        _rl_vi_textmod_command (key))
      _rl_vi_set_last (key, rl_numeric_arg, rl_arg_sign);
*** ../bash-4.3/patchlevel.h	2012-12-29 10:47:57.000000000 -0500
--- patchlevel.h	2014-03-20 20:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 3
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 4
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.3
Patch-ID:	bash43-005

Bug-Reported-by:	David Sines <dave.gma@googlemail.com>
Bug-Reference-ID:	<CAO3BAa_CK_Rgkhdfzs+NJ4KFYdB9qW3pvXQK0xLCi6GMmDU8bw@mail.gmail.com>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2014-03/msg00037.html

Bug-Description:

When in Posix mode, bash did not correctly interpret the ANSI-C-style
$'...' quoting mechanism when performing pattern substitution word
expansions within double quotes.

Patch (apply with `patch -p0'):

*** ../bash-4.3/parse.y	2014-02-11 09:42:10.000000000 -0500
--- parse.y	2014-03-07 20:57:15.000000000 -0500
***************
*** 3399,3403 ****
           unescaped double-quotes or single-quotes, if any, shall occur." */
        /* This was changed in Austin Group Interp 221 */
!       if MBTEST(posixly_correct && shell_compatibility_level > 41 && dolbrace_state != DOLBRACE_QUOTE && (flags & P_DQUOTE) && (flags & P_DOLBRACE) && ch == '\'')
  	continue;
  
--- 3399,3403 ----
           unescaped double-quotes or single-quotes, if any, shall occur." */
        /* This was changed in Austin Group Interp 221 */
!       if MBTEST(posixly_correct && shell_compatibility_level > 41 && dolbrace_state != DOLBRACE_QUOTE && dolbrace_state != DOLBRACE_QUOTE2 && (flags & P_DQUOTE) && (flags & P_DOLBRACE) && ch == '\'')
  	continue;
  
*** ../bash-4.3/y.tab.c	2014-02-11 10:57:47.000000000 -0500
--- y.tab.c	2014-03-28 10:41:15.000000000 -0400
***************
*** 5711,5715 ****
           unescaped double-quotes or single-quotes, if any, shall occur." */
        /* This was changed in Austin Group Interp 221 */
!       if MBTEST(posixly_correct && shell_compatibility_level > 41 && dolbrace_state != DOLBRACE_QUOTE && (flags & P_DQUOTE) && (flags & P_DOLBRACE) && ch == '\'')
  	continue;
  
--- 5711,5715 ----
           unescaped double-quotes or single-quotes, if any, shall occur." */
        /* This was changed in Austin Group Interp 221 */
!       if MBTEST(posixly_correct && shell_compatibility_level > 41 && dolbrace_state != DOLBRACE_QUOTE && dolbrace_state != DOLBRACE_QUOTE2 && (flags & P_DQUOTE) && (flags & P_DOLBRACE) && ch == '\'')
  	continue;
  
*** ../bash-4.3/patchlevel.h	2012-12-29 10:47:57.000000000 -0500
--- patchlevel.h	2014-03-20 20:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 4
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 5
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.3
Patch-ID:	bash43-006

Bug-Reported-by:	Eduardo A . Bustamante Lopez <dualbus@gmail.com>
Bug-Reference-ID:	<20140228170013.GA16015@dualbus.me>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2014-02/msg00091.html

Bug-Description:

A shell that started with job control active but was not interactive left
the terminal in the wrong process group when exiting, causing its parent
shell to get a stop signal when it attempted to read from the terminal.

Patch (apply with `patch -p0'):

*** ../bash-4.3/jobs.c	2014-01-10 09:05:34.000000000 -0500
--- jobs.c	2014-03-02 18:05:09.000000000 -0500
***************
*** 4375,4379 ****
  end_job_control ()
  {
!   if (interactive_shell)		/* XXX - should it be interactive? */
      {
        terminate_stopped_jobs ();
--- 4375,4379 ----
  end_job_control ()
  {
!   if (interactive_shell || job_control)		/* XXX - should it be just job_control? */
      {
        terminate_stopped_jobs ();
*** ../bash-4.3/patchlevel.h	2012-12-29 10:47:57.000000000 -0500
--- patchlevel.h	2014-03-20 20:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 5
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 6
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.3
Patch-ID:	bash43-007

Bug-Reported-by:	geir.hauge@gmail.com
Bug-Reference-ID:	<20140318093650.B181C1C5B0B@gina.itea.ntnu.no>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2014-03/msg00095.html

Bug-Description:

Using compound assignments for associative arrays like

assoc=( [x]= [y]=bar )

left the value corresponding to the key `x' NULL.  This caused subsequent
lookups to interpret it as unset.

Patch (apply with `patch -p0'):

*** ../bash-4.3/arrayfunc.c	2013-08-02 16:19:59.000000000 -0400
--- arrayfunc.c	2014-03-18 11:08:15.000000000 -0400
***************
*** 598,601 ****
--- 598,606 ----
  	{
  	  val = expand_assignment_string_to_string (val, 0);
+ 	  if (val == 0)
+ 	    {
+ 	      val = (char *)xmalloc (1);
+ 	      val[0] = '\0';	/* like do_assignment_internal */
+ 	    }
  	  free_val = 1;
  	}
*** ../bash-4.3/patchlevel.h	2012-12-29 10:47:57.000000000 -0500
--- patchlevel.h	2014-03-20 20:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 6
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 7
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.3
Patch-ID:	bash43-008

Bug-Reported-by:	Stephane Chazelas <stephane.chazelas@gmail.com>
Bug-Reference-ID:	<20140318135901.GB22158@chaz.gmail.com>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2014-03/msg00098.html

Bug-Description:

Some extended glob patterns incorrectly matched filenames with a leading
dot, regardless of the setting of the `dotglob' option.

Patch (apply with `patch -p0'):

*** ../bash-4.3/lib/glob/gmisc.c	2013-10-28 14:45:25.000000000 -0400
--- lib/glob/gmisc.c	2014-03-19 09:16:08.000000000 -0400
***************
*** 211,214 ****
--- 211,215 ----
      case '!':
      case '@':
+     case '?':
        return (pat[1] == LPAREN);
      default:
*** ../bash-4.3/lib/glob/glob.c	2014-01-31 21:43:51.000000000 -0500
--- lib/glob/glob.c	2014-03-20 09:01:26.000000000 -0400
***************
*** 180,202 ****
       int flags;
  {
!   char *pp, *pe, *t;
!   int n, r;
  
    pp = pat + 2;
!   pe = pp + strlen (pp) - 1;	/*(*/
!   if (*pe != ')')
!     return 0;
!   if ((t = strchr (pp, '|')) == 0)	/* easy case first */
      {
        *pe = '\0';
        r = skipname (pp, dname, flags);	/*(*/
        *pe = ')';
        return r;
      }
    while (t = glob_patscan (pp, pe, '|'))
      {
        n = t[-1];
        t[-1] = '\0';
        r = skipname (pp, dname, flags);
        t[-1] = n;
        if (r == 0)	/* if any pattern says not skip, we don't skip */
--- 180,215 ----
       int flags;
  {
!   char *pp, *pe, *t, *se;
!   int n, r, negate;
  
+   negate = *pat == '!';
    pp = pat + 2;
!   se = pp + strlen (pp) - 1;		/* end of string */
!   pe = glob_patscan (pp, se, 0);	/* end of extglob pattern (( */
!   /* we should check for invalid extglob pattern here */
!   /* if pe != se we have more of the pattern at the end of the extglob
!      pattern. Check the easy case first ( */
!   if (pe == se && *pe == ')' && (t = strchr (pp, '|')) == 0)
      {
        *pe = '\0';
+ #if defined (HANDLE_MULTIBYTE)
+       r = mbskipname (pp, dname, flags);
+ #else
        r = skipname (pp, dname, flags);	/*(*/
+ #endif
        *pe = ')';
        return r;
      }
+ 
+   /* check every subpattern */
    while (t = glob_patscan (pp, pe, '|'))
      {
        n = t[-1];
        t[-1] = '\0';
+ #if defined (HANDLE_MULTIBYTE)
+       r = mbskipname (pp, dname, flags);
+ #else
        r = skipname (pp, dname, flags);
+ #endif
        t[-1] = n;
        if (r == 0)	/* if any pattern says not skip, we don't skip */
***************
*** 205,219 ****
      }	/*(*/
  
!   if (pp == pe)		/* glob_patscan might find end of pattern */
      return r;
  
!   *pe = '\0';
! #  if defined (HANDLE_MULTIBYTE)
!   r = mbskipname (pp, dname, flags);	/*(*/
! #  else
!   r = skipname (pp, dname, flags);	/*(*/
! #  endif
!   *pe = ')';
!   return r;
  }
  #endif
--- 218,227 ----
      }	/*(*/
  
!   /* glob_patscan might find end of pattern */
!   if (pp == se)
      return r;
  
!   /* but if it doesn't then we didn't match a leading dot */
!   return 0;
  }
  #endif
***************
*** 278,289 ****
  {
  #if EXTENDED_GLOB
!   wchar_t *pp, *pe, *t, n;
!   int r;
  
    pp = pat + 2;
!   pe = pp + wcslen (pp) - 1;	/*(*/
!   if (*pe != L')')
!     return 0;
!   if ((t = wcschr (pp, L'|')) == 0)
      {
        *pe = L'\0';
--- 286,298 ----
  {
  #if EXTENDED_GLOB
!   wchar_t *pp, *pe, *t, n, *se;
!   int r, negate;
  
+   negate = *pat == L'!';
    pp = pat + 2;
!   se = pp + wcslen (pp) - 1;	/*(*/
!   pe = glob_patscan_wc (pp, se, 0);
! 
!   if (pe == se && *pe == ')' && (t = wcschr (pp, L'|')) == 0)
      {
        *pe = L'\0';
***************
*** 292,295 ****
--- 301,306 ----
        return r;
      }
+ 
+   /* check every subpattern */
    while (t = glob_patscan_wc (pp, pe, '|'))
      {
***************
*** 306,313 ****
      return r;
  
!   *pe = L'\0';
!   r = wchkname (pp, dname);	/*(*/
!   *pe = L')';
!   return r;
  #else
    return (wchkname (pat, dname));
--- 317,322 ----
      return r;
  
!   /* but if it doesn't then we didn't match a leading dot */
!   return 0;
  #else
    return (wchkname (pat, dname));
*** ../bash-4.3/patchlevel.h	2012-12-29 10:47:57.000000000 -0500
--- patchlevel.h	2014-03-20 20:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 7
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 8
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.3
Patch-ID:	bash43-009

Bug-Reported-by:	Matthias Klose <doko@debian.org>
Bug-Reference-ID:	<53346FC8.6090005@debian.org>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2014-03/msg00171.html

Bug-Description:

There is a problem with unsigned sign extension when attempting to reallocate
the input line when it is fewer than 3 characters long and there has been a
history expansion.  The sign extension causes the shell to not reallocate the
line, which results in a segmentation fault when it writes past the end.

Patch (apply with `patch -p0'):

*** ../bash-4.3-patched/parse.y	2014-02-11 09:42:10.000000000 -0500
--- parse.y	2014-03-27 16:33:29.000000000 -0400
***************
*** 2425,2429 ****
        if (shell_input_line_terminator != EOF)
  	{
! 	  if (shell_input_line_size < SIZE_MAX && shell_input_line_len > shell_input_line_size - 3)
  	    shell_input_line = (char *)xrealloc (shell_input_line,
  					1 + (shell_input_line_size += 2));
--- 2425,2429 ----
        if (shell_input_line_terminator != EOF)
  	{
! 	  if (shell_input_line_size < SIZE_MAX-3 && (shell_input_line_len+3 > shell_input_line_size))
  	    shell_input_line = (char *)xrealloc (shell_input_line,
  					1 + (shell_input_line_size += 2));
*** ../bash-4.3-patched/y.tab.c	2014-03-28 11:17:06.000000000 -0400
--- y.tab.c	2014-04-07 11:48:31.000000000 -0400
***************
*** 4737,4741 ****
        if (shell_input_line_terminator != EOF)
  	{
! 	  if (shell_input_line_size < SIZE_MAX && shell_input_line_len > shell_input_line_size - 3)
  	    shell_input_line = (char *)xrealloc (shell_input_line,
  					1 + (shell_input_line_size += 2));
--- 4737,4741 ----
        if (shell_input_line_terminator != EOF)
  	{
! 	  if (shell_input_line_size < SIZE_MAX-3 && (shell_input_line_len+3 > shell_input_line_size))
  	    shell_input_line = (char *)xrealloc (shell_input_line,
  					1 + (shell_input_line_size += 2));
*** ../bash-4.3/patchlevel.h	2012-12-29 10:47:57.000000000 -0500
--- patchlevel.h	2014-03-20 20:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 8
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 9
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.3
Patch-ID:	bash43-010

Bug-Reported-by:	Albert Shih <Albert.Shih@obspm.fr>
Bug-Reference-ID:	Wed, 5 Mar 2014 23:01:40 +0100
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2014-03/msg00028.html

Bug-Description:

Patch (apply with `patch -p0'):

This patch changes the behavior of programmable completion to compensate
for two assumptions made by the bash-completion package.  Bash-4.3 changed
to dequote the argument to programmable completion only under certain
circumstances, to make the behavior of compgen more consistent when run
from the command line -- closer to the behavior when run by a shell function
run as part of programmable completion.  Bash-completion can pass quoted
arguments to compgen when the original word to be completed was not quoted,
expecting programmable completion to dequote the word before attempting
completion.

This patch fixes two cases:

1.  An empty string that bash-completion passes to compgen as a quoted null
    string ('').

2.  An unquoted word that bash-completion quotes using single quotes or
    backslashes before passing it to compgen.

In these cases, since readline did not detect a quote character in the original
word to be completed, bash-4.3 

*** ../bash-4.3/externs.h	2014-01-02 14:58:20.000000000 -0500
--- externs.h	2014-03-13 14:42:57.000000000 -0400
***************
*** 325,328 ****
--- 325,329 ----
  extern char *sh_backslash_quote_for_double_quotes __P((char *));
  extern int sh_contains_shell_metas __P((char *));
+ extern int sh_contains_quotes __P((char *));
  
  /* declarations for functions defined in lib/sh/spell.c */
*** ../bash-4.3/lib/sh/shquote.c	2013-03-31 21:53:32.000000000 -0400
--- lib/sh/shquote.c	2014-03-13 14:42:57.000000000 -0400
***************
*** 312,313 ****
--- 312,327 ----
    return (0);
  }
+ 
+ int
+ sh_contains_quotes (string)
+      char *string;
+ {
+   char *s;
+ 
+   for (s = string; s && *s; s++)
+     {
+       if (*s == '\'' || *s == '"' || *s == '\\')
+ 	return 1;
+     }
+   return 0;
+ }
*** ../bash-4.3/pcomplete.c	2013-08-26 15:23:45.000000000 -0400
--- pcomplete.c	2014-03-25 17:23:23.000000000 -0400
***************
*** 184,187 ****
--- 184,188 ----
  COMPSPEC *pcomp_curcs;
  const char *pcomp_curcmd;
+ const char *pcomp_curtxt;
  
  #ifdef DEBUG
***************
*** 754,757 ****
--- 755,784 ----
  	  dfn = (*rl_filename_dequoting_function) ((char *)text, rl_completion_quote_character);
  	}
+       /* Intended to solve a mismatched assumption by bash-completion.  If
+ 	 the text to be completed is empty, but bash-completion turns it into
+ 	 a quoted string ('') assuming that this code will dequote it before
+ 	 calling readline, do the dequoting. */
+       else if (iscompgen && iscompleting &&
+ 	       pcomp_curtxt && *pcomp_curtxt == 0 &&
+ 	       text && (*text == '\'' || *text == '"') && text[1] == text[0] && text[2] == 0 && 
+ 	       rl_filename_dequoting_function)
+ 	dfn = (*rl_filename_dequoting_function) ((char *)text, rl_completion_quote_character);
+       /* Another mismatched assumption by bash-completion.  If compgen is being
+       	 run as part of bash-completion, and the argument to compgen is not
+       	 the same as the word originally passed to the programmable completion
+       	 code, dequote the argument if it has quote characters.  It's an
+       	 attempt to detect when bash-completion is quoting its filename
+       	 argument before calling compgen. */
+       /* We could check whether gen_shell_function_matches is in the call
+ 	 stack by checking whether the gen-shell-function-matches tag is in
+ 	 the unwind-protect stack, but there's no function to do that yet.
+ 	 We could simply check whether we're executing in a function by
+ 	 checking variable_context, and may end up doing that. */
+       else if (iscompgen && iscompleting && rl_filename_dequoting_function &&
+ 	       pcomp_curtxt && text &&
+ 	       STREQ (pcomp_curtxt, text) == 0 &&
+ 	       variable_context &&
+ 	       sh_contains_quotes (text))	/* guess */
+ 	dfn = (*rl_filename_dequoting_function) ((char *)text, rl_completion_quote_character);
        else
  	dfn = savestring (text);
***************
*** 1523,1527 ****
  {
    COMPSPEC *cs, *oldcs;
!   const char *oldcmd;
    STRINGLIST *ret;
  
--- 1550,1554 ----
  {
    COMPSPEC *cs, *oldcs;
!   const char *oldcmd, *oldtxt;
    STRINGLIST *ret;
  
***************
*** 1546,1552 ****
--- 1573,1581 ----
    oldcs = pcomp_curcs;
    oldcmd = pcomp_curcmd;
+   oldtxt = pcomp_curtxt;
  
    pcomp_curcs = cs;
    pcomp_curcmd = cmd;
+   pcomp_curtxt = word;
  
    ret = gen_compspec_completions (cs, cmd, word, start, end, foundp);
***************
*** 1554,1557 ****
--- 1583,1587 ----
    pcomp_curcs = oldcs;
    pcomp_curcmd = oldcmd;
+   pcomp_curtxt = oldtxt;
  
    /* We need to conditionally handle setting *retryp here */
*** ../bash-4.3/patchlevel.h	2012-12-29 10:47:57.000000000 -0500
--- patchlevel.h	2014-03-20 20:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 9
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 10
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.3
Patch-ID:	bash43-011

Bug-Reported-by:	Egmont Koblinger <egmont@gmail.com>
Bug-Reference-ID:	<CAGWcZk+bU5Jo1M+tutGvL-250UBE9DXjpeJVofYJSFcqFEVfMg@mail.gmail.com>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2014-03/msg00153.html

Bug-Description:

The signal handling changes to bash and readline (to avoid running any code
in a signal handler context) cause the cursor to be placed on the wrong
line of a multi-line command after a ^C interrupts editing.

Patch (apply with `patch -p0'):

*** ../bash-4.3-patched/lib/readline/display.c	2013-12-27 13:10:56.000000000 -0500
--- lib/readline/display.c	2014-03-27 11:52:45.000000000 -0400
***************
*** 2678,2682 ****
    if (_rl_echoing_p)
      {
!       _rl_move_vert (_rl_vis_botlin);
        _rl_vis_botlin = 0;
        fflush (rl_outstream);
--- 2678,2683 ----
    if (_rl_echoing_p)
      {
!       if (_rl_vis_botlin > 0)	/* minor optimization plus bug fix */
! 	_rl_move_vert (_rl_vis_botlin);
        _rl_vis_botlin = 0;
        fflush (rl_outstream);
*** ../bash-4.3/patchlevel.h	2012-12-29 10:47:57.000000000 -0500
--- patchlevel.h	2014-03-20 20:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 10
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 11
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.3
Patch-ID:	bash43-012

Bug-Reported-by:	Eduardo A. Bustamante López<dualbus@gmail.com>
Bug-Reference-ID:	<5346B54C.4070205@case.edu>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2014-04/msg00051.html

Bug-Description:

When a SIGCHLD trap runs a command containing a shell builtin while
a script is running `wait' to wait for all running children to complete,
the SIGCHLD trap will not be run once for each child that terminates.

Patch (apply with `patch -p0'):

*** ../bash-4.3-patched/jobs.c	2014-03-28 10:54:19.000000000 -0400
--- jobs.c	2014-04-15 08:47:03.000000000 -0400
***************
*** 3598,3601 ****
--- 3598,3602 ----
    unwind_protect_pointer (the_pipeline);
    unwind_protect_pointer (subst_assign_varlist);
+   unwind_protect_pointer (this_shell_builtin);
  
    /* We have to add the commands this way because they will be run
*** ../bash-4.3/patchlevel.h	2012-12-29 10:47:57.000000000 -0500
--- patchlevel.h	2014-03-20 20:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 11
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 12
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.3
Patch-ID:	bash43-013

Bug-Reported-by:	<Trond.Endrestol@ximalas.info>
Bug-Reference-ID:	<alpine.BSF.2.03.1404192114310.1973@enterprise.ximalas.info>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2014-04/msg00069.html

Bug-Description:

Using reverse-i-search when horizontal scrolling is enabled does not redisplay
the entire line containing the successful search results.

Patch (apply with `patch -p0'):
*** ../bash-4.3-patched/lib/readline/display.c	2014-04-08 18:19:36.000000000 -0400
--- lib/readline/display.c	2014-04-20 18:32:52.000000000 -0400
***************
*** 1638,1642 ****
       the spot of first difference is before the end of the invisible chars,
       lendiff needs to be adjusted. */
!   if (current_line == 0 && !_rl_horizontal_scroll_mode &&
        current_invis_chars != visible_wrap_offset)
      {
--- 1638,1642 ----
       the spot of first difference is before the end of the invisible chars,
       lendiff needs to be adjusted. */
!   if (current_line == 0 && /* !_rl_horizontal_scroll_mode && */
        current_invis_chars != visible_wrap_offset)
      {
***************
*** 1826,1831 ****
  		_rl_last_c_pos += bytes_to_insert;
  
  	      if (_rl_horizontal_scroll_mode && ((oe-old) > (ne-new)))
! 		goto clear_rest_of_line;
  	    }
  	}
--- 1826,1836 ----
  		_rl_last_c_pos += bytes_to_insert;
  
+ 	      /* XXX - we only want to do this if we are at the end of the line
+ 		 so we move there with _rl_move_cursor_relative */
  	      if (_rl_horizontal_scroll_mode && ((oe-old) > (ne-new)))
! 		{
! 		  _rl_move_cursor_relative (ne-new, new);
! 		  goto clear_rest_of_line;
! 		}
  	    }
  	}
*** ../bash-4.3/patchlevel.h	2012-12-29 10:47:57.000000000 -0500
--- patchlevel.h	2014-03-20 20:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 12
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 13
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.3
Patch-ID:	bash43-014

Bug-Reported-by:	Greg Wooledge <wooledg@eeg.ccf.org>
Bug-Reference-ID:	<20140418202123.GB7660@eeg.ccf.org>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/help-bash/2014-04/msg00004.html

Bug-Description:

Under certain circumstances, $@ is expanded incorrectly in contexts where
word splitting is not performed.

Patch (apply with `patch -p0'):
*** ../bash-4.3-patched/subst.c	2014-01-23 16:26:37.000000000 -0500
--- subst.c	2014-04-19 15:41:26.000000000 -0400
***************
*** 3249,3254 ****
--- 3249,3256 ----
      return ((char *)NULL);
  
+   expand_no_split_dollar_star = 1;
    w->flags |= W_NOSPLIT2;
    l = call_expand_word_internal (w, 0, 0, (int *)0, (int *)0);
+   expand_no_split_dollar_star = 0;
    if (l)
      {
***************
*** 7848,7851 ****
--- 7850,7857 ----
  	 according to POSIX.2, this expands to a list of the positional
  	 parameters no matter what IFS is set to. */
+       /* XXX - what to do when in a context where word splitting is not
+ 	 performed? Even when IFS is not the default, posix seems to imply
+ 	 that we behave like unquoted $* ?  Maybe we should use PF_NOSPLIT2
+ 	 here. */
        temp = string_list_dollar_at (list, (pflags & PF_ASSIGNRHS) ? (quoted|Q_DOUBLE_QUOTES) : quoted);
  
***************
*** 8817,8820 ****
--- 8823,8827 ----
      {
        char *ifs_chars;
+       char *tstring;
  
        ifs_chars = (quoted_dollar_at || has_dollar_at) ? ifs_value : (char *)NULL;
***************
*** 8831,8834 ****
--- 8838,8865 ----
        if (split_on_spaces)
  	list = list_string (istring, " ", 1);	/* XXX quoted == 1? */
+       /* If we have $@ (has_dollar_at != 0) and we are in a context where we
+ 	 don't want to split the result (W_NOSPLIT2), and we are not quoted,
+ 	 we have already separated the arguments with the first character of
+ 	 $IFS.  In this case, we want to return a list with a single word
+ 	 with the separator possibly replaced with a space (it's what other
+ 	 shells seem to do).
+ 	 quoted_dollar_at is internal to this function and is set if we are
+ 	 passed an argument that is unquoted (quoted == 0) but we encounter a
+ 	 double-quoted $@ while expanding it. */
+       else if (has_dollar_at && quoted_dollar_at == 0 && ifs_chars && quoted == 0 && (word->flags & W_NOSPLIT2))
+ 	{
+ 	  /* Only split and rejoin if we have to */
+ 	  if (*ifs_chars && *ifs_chars != ' ')
+ 	    {
+ 	      list = list_string (istring, *ifs_chars ? ifs_chars : " ", 1);
+ 	      tstring = string_list (list);
+ 	    }
+ 	  else
+ 	    tstring = istring;
+ 	  tword = make_bare_word (tstring);
+ 	  if (tstring != istring)
+ 	    free (tstring);
+ 	  goto set_word_flags;
+ 	}
        else if (has_dollar_at && ifs_chars)
  	list = list_string (istring, *ifs_chars ? ifs_chars : " ", 1);
***************
*** 8836,8839 ****
--- 8867,8871 ----
  	{
  	  tword = make_bare_word (istring);
+ set_word_flags:
  	  if ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) || (quoted_state == WHOLLY_QUOTED))
  	    tword->flags |= W_QUOTED;
*** ../bash-4.3/patchlevel.h	2012-12-29 10:47:57.000000000 -0500
--- patchlevel.h	2014-03-20 20:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 13
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 14
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.3
Patch-ID:	bash43-015

Bug-Reported-by:	Clark Wang <dearvoid@gmail.com>
Bug-Reference-ID:	<CADv8-og2TOSoabXeNVXVGaXN3tEMHnYVq1rwOLe5meaRPSGRig@mail.gmail.com>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2014-04/msg00095.html

Bug-Description:

When completing directory names, the directory name is dequoted twice.
This causes problems for directories with single and double quotes in
their names.

Patch (apply with `patch -p0'):
*** ../bash-4.3-patched/bashline.c	2014-02-09 19:56:58.000000000 -0500
--- bashline.c	2014-04-25 14:57:52.000000000 -0400
***************
*** 4168,4174 ****
  
    qc = rl_dispatching ? rl_completion_quote_character : 0;  
!   dfn = bash_dequote_filename ((char *)text, qc);
    m1 = rl_completion_matches (dfn, rl_filename_completion_function);
!   free (dfn);
  
    if (m1 == 0 || m1[0] == 0)
--- 4209,4222 ----
  
    qc = rl_dispatching ? rl_completion_quote_character : 0;  
!   /* If rl_completion_found_quote != 0, rl_completion_matches will call the
!      filename dequoting function, causing the directory name to be dequoted
!      twice. */
!   if (rl_dispatching && rl_completion_found_quote == 0)
!     dfn = bash_dequote_filename ((char *)text, qc);
!   else
!     dfn = (char *)text;
    m1 = rl_completion_matches (dfn, rl_filename_completion_function);
!   if (dfn != text)
!     free (dfn);
  
    if (m1 == 0 || m1[0] == 0)
*** ../bash-4.3/patchlevel.h	2012-12-29 10:47:57.000000000 -0500
--- patchlevel.h	2014-03-20 20:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 14
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 15
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.3
Patch-ID:	bash43-016

Bug-Reported-by:	Pierre Gaston <pierre.gaston@gmail.com>
Bug-Reference-ID:	<CAPSX3sTCD61k1VQLJ5r-LWzEt+e7Xc-fxXmwn2u8EA5gJJej8Q@mail.gmail.com>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2014-04/msg00100.html

Bug-Description:

An extended glob pattern containing a slash (`/') causes the globbing code
to misinterpret it as a directory separator.

Patch (apply with `patch -p0'):
*** ../bash-4.3-patched/lib/glob/glob.c	2014-03-28 10:54:23.000000000 -0400
--- lib/glob/glob.c	2014-05-02 10:24:28.000000000 -0400
***************
*** 124,127 ****
--- 124,129 ----
  extern wchar_t *glob_patscan_wc __P((wchar_t *, wchar_t *, int));
  
+ extern char *glob_dirscan __P((char *, int));
+ 
  /* Compile `glob_loop.c' for single-byte characters. */
  #define CHAR	unsigned char
***************
*** 188,191 ****
--- 190,196 ----
    pe = glob_patscan (pp, se, 0);	/* end of extglob pattern (( */
    /* we should check for invalid extglob pattern here */
+   if (pe == 0)
+     return 0;
+ 
    /* if pe != se we have more of the pattern at the end of the extglob
       pattern. Check the easy case first ( */
***************
*** 1016,1020 ****
    char **result;
    unsigned int result_size;
!   char *directory_name, *filename, *dname;
    unsigned int directory_len;
    int free_dirname;			/* flag */
--- 1021,1025 ----
    char **result;
    unsigned int result_size;
!   char *directory_name, *filename, *dname, *fn;
    unsigned int directory_len;
    int free_dirname;			/* flag */
***************
*** 1032,1035 ****
--- 1037,1052 ----
    /* Find the filename.  */
    filename = strrchr (pathname, '/');
+ #if defined (EXTENDED_GLOB)
+   if (filename && extended_glob)
+     {
+       fn = glob_dirscan (pathname, '/');
+ #if DEBUG_MATCHING
+       if (fn != filename)
+ 	fprintf (stderr, "glob_filename: glob_dirscan: fn (%s) != filename (%s)\n", fn ? fn : "(null)", filename);
+ #endif
+       filename = fn;
+     }
+ #endif
+ 
    if (filename == NULL)
      {
*** ../bash-4.3-patched/lib/glob/gmisc.c	2014-03-28 10:54:23.000000000 -0400
--- lib/glob/gmisc.c	2014-05-02 09:35:57.000000000 -0400
***************
*** 43,46 ****
--- 43,48 ----
  #define WRPAREN         L')'
  
+ extern char *glob_patscan __P((char *, char *, int));
+ 
  /* Return 1 of the first character of WSTRING could match the first
     character of pattern WPAT.  Wide character version. */
***************
*** 376,377 ****
--- 378,410 ----
    return matlen;
  }
+ 
+ /* Skip characters in PAT and return the final occurrence of DIRSEP.  This
+    is only called when extended_glob is set, so we have to skip over extglob
+    patterns x(...) */
+ char *
+ glob_dirscan (pat, dirsep)
+      char *pat;
+      int dirsep;
+ {
+   char *p, *d, *pe, *se;
+ 
+   d = pe = se = 0;
+   for (p = pat; p && *p; p++)
+     {
+       if (extglob_pattern_p (p))
+ 	{
+ 	  if (se == 0)
+ 	    se = p + strlen (p) - 1;
+ 	  pe = glob_patscan (p + 2, se, 0);
+ 	  if (pe == 0)
+ 	    continue;
+ 	  else if (*pe == 0)
+ 	    break;
+ 	  p = pe - 1;	/* will do increment above */
+ 	  continue;
+ 	}
+       if (*p ==  dirsep)
+ 	d = p;
+     }
+   return d;
+ }

*** ../bash-4.3/patchlevel.h	2012-12-29 10:47:57.000000000 -0500
--- patchlevel.h	2014-03-20 20:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 15
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 16
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.3
Patch-ID:	bash43-017

Bug-Reported-by:	Dan Douglas <ormaaj@gmail.com>
Bug-Reference-ID:	<7781746.RhfoTROLxF@smorgbox>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2014-05/msg00026.html

Bug-Description:

The code that creates local variables should not clear the `invisible'
attribute when returning an existing local variable.  Let the code that
actually assigns a value clear it.

Patch (apply with `patch -p0'):
*** ../bash-4.3-patched/variables.c	2014-02-14 11:55:12.000000000 -0500
--- variables.c	2014-05-07 10:53:57.000000000 -0400
***************
*** 2198,2205 ****
    old_var = find_variable (name);
    if (old_var && local_p (old_var) && old_var->context == variable_context)
!     {
!       VUNSETATTR (old_var, att_invisible);	/* XXX */
!       return (old_var);
!     }
  
    was_tmpvar = old_var && tempvar_p (old_var);
--- 2260,2264 ----
    old_var = find_variable (name);
    if (old_var && local_p (old_var) && old_var->context == variable_context)
!     return (old_var);
  
    was_tmpvar = old_var && tempvar_p (old_var);

*** ../bash-4.3/patchlevel.h	2012-12-29 10:47:57.000000000 -0500
--- patchlevel.h	2014-03-20 20:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 16
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 17
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.3
Patch-ID:	bash43-018

Bug-Reported-by:	Geir Hauge <geir.hauge@gmail.com>
Bug-Reference-ID:	<CAO-BiTLOvfPXDypg61jcBausADrxUKJejakV2WTWP26cW0=rgA@mail.gmail.com>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2014-05/msg00040.html

Bug-Description:

When assigning an array variable using the compound assignment syntax,
but using `declare' with the rhs of the compound assignment quoted, the
shell did not mark the variable as visible after successfully performing
the assignment.

Patch (apply with `patch -p0'):
*** ../bash-4.3-patched/arrayfunc.c	2014-03-28 10:54:21.000000000 -0400
--- arrayfunc.c	2014-05-12 11:19:00.000000000 -0400
***************
*** 180,183 ****
--- 180,184 ----
    FREE (newval);
  
+   VUNSETATTR (entry, att_invisible);	/* no longer invisible */
    return (entry);
  }

*** ../bash-4.3/patchlevel.h	2012-12-29 10:47:57.000000000 -0500
--- patchlevel.h	2014-03-20 20:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 17
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 18
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.3
Patch-ID:	bash43-019

Bug-Reported-by:	John Lenton
Bug-Reference-ID:
Bug-Reference-URL:	https://bugs.launchpad.net/ubuntu/+source/bash/+bug/1317476

Bug-Description:

The -t timeout option to `read' does not work when the -e option is used.

Patch (apply with `patch -p0'):

*** ../bash-4.3-patched/lib/readline/input.c	2014-01-10 15:07:08.000000000 -0500
--- lib/readline/input.c	2014-05-22 18:40:59.000000000 -0400
***************
*** 535,540 ****
--- 538,551 ----
        else if (_rl_caught_signal == SIGHUP || _rl_caught_signal == SIGTERM)
  	return (RL_ISSTATE (RL_STATE_READCMD) ? READERR : EOF);
+       /* keyboard-generated signals of interest */
        else if (_rl_caught_signal == SIGINT || _rl_caught_signal == SIGQUIT)
          RL_CHECK_SIGNALS ();
+       /* non-keyboard-generated signals of interest */
+       else if (_rl_caught_signal == SIGALRM
+ #if defined (SIGVTALRM)
+ 		|| _rl_caught_signal == SIGVTALRM
+ #endif
+ 	      )
+         RL_CHECK_SIGNALS ();
  
        if (rl_signal_event_hook)
*** ../bash-4.3-patched/builtins/read.def	2013-09-02 11:54:00.000000000 -0400
--- builtins/read.def	2014-05-08 11:43:35.000000000 -0400
***************
*** 443,447 ****
  #if defined (READLINE)
        if (edit)
! 	add_unwind_protect (reset_attempted_completion_function, (char *)NULL);
  #endif
        falarm (tmsec, tmusec);
--- 443,450 ----
  #if defined (READLINE)
        if (edit)
! 	{
! 	  add_unwind_protect (reset_attempted_completion_function, (char *)NULL);
! 	  add_unwind_protect (bashline_reset_event_hook, (char *)NULL);
! 	}
  #endif
        falarm (tmsec, tmusec);
***************
*** 1022,1025 ****
--- 1025,1029 ----
    old_attempted_completion_function = rl_attempted_completion_function;
    rl_attempted_completion_function = (rl_completion_func_t *)NULL;
+   bashline_set_event_hook ();
    if (itext)
      {
***************
*** 1033,1036 ****
--- 1037,1041 ----
    rl_attempted_completion_function = old_attempted_completion_function;
    old_attempted_completion_function = (rl_completion_func_t *)NULL;
+   bashline_reset_event_hook ();
  
    if (ret == 0)
*** ../bash-4.3/patchlevel.h	2012-12-29 10:47:57.000000000 -0500
--- patchlevel.h	2014-03-20 20:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 18
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 19
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.3
Patch-ID:	bash43-020

Bug-Reported-by:	Jared Yanovich <slovichon@gmail.com>
Bug-Reference-ID:	<20140417073654.GB26875@nightderanger.psc.edu>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2014-04/msg00065.html

Bug-Description:

When PS2 contains a command substitution, here-documents entered in an
interactive shell can sometimes cause a segmentation fault.

Patch (apply with `patch -p0'):

*** ../bash-4.3-patched/shell.h	2012-12-25 21:11:01.000000000 -0500
--- shell.h	2014-06-03 09:24:28.000000000 -0400
***************
*** 169,173 ****
    int expand_aliases;
    int echo_input_at_read;
!   
  } sh_parser_state_t;
  
--- 169,174 ----
    int expand_aliases;
    int echo_input_at_read;
!   int need_here_doc;
! 
  } sh_parser_state_t;
  
*** ../bash-4.3-patched/parse.y	2014-05-14 09:16:40.000000000 -0400
--- parse.y	2014-04-30 09:27:59.000000000 -0400
***************
*** 2643,2647 ****
  
    r = 0;
!   while (need_here_doc)
      {
        parser_state |= PST_HEREDOC;
--- 2643,2647 ----
  
    r = 0;
!   while (need_here_doc > 0)
      {
        parser_state |= PST_HEREDOC;
***************
*** 6076,6079 ****
--- 6076,6080 ----
    ps->expand_aliases = expand_aliases;
    ps->echo_input_at_read = echo_input_at_read;
+   ps->need_here_doc = need_here_doc;
  
    ps->token = token;
***************
*** 6124,6127 ****
--- 6125,6129 ----
    expand_aliases = ps->expand_aliases;
    echo_input_at_read = ps->echo_input_at_read;
+   need_here_doc = ps->need_here_doc;
  
    FREE (token);
*** ../bash-4.3-patched/y.tab.c	2014-04-07 11:56:12.000000000 -0400
--- y.tab.c	2014-07-30 09:55:57.000000000 -0400
***************
*** 4955,4959 ****
  
    r = 0;
!   while (need_here_doc)
      {
        parser_state |= PST_HEREDOC;
--- 5151,5155 ----
  
    r = 0;
!   while (need_here_doc > 0)
      {
        parser_state |= PST_HEREDOC;
***************
*** 8388,8391 ****
--- 8584,8588 ----
    ps->expand_aliases = expand_aliases;
    ps->echo_input_at_read = echo_input_at_read;
+   ps->need_here_doc = need_here_doc;
  
    ps->token = token;
***************
*** 8436,8439 ****
--- 8633,8637 ----
    expand_aliases = ps->expand_aliases;
    echo_input_at_read = ps->echo_input_at_read;
+   need_here_doc = ps->need_here_doc;
  
    FREE (token);
*** ../bash-4.3/patchlevel.h	2012-12-29 10:47:57.000000000 -0500
--- patchlevel.h	2014-03-20 20:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 19
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 20
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.3
Patch-ID:	bash43-021

Bug-Reported-by:	Jared Yanovich <slovichon@gmail.com>
Bug-Reference-ID:	<20140625225019.GJ17044@nightderanger.psc.edu>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2014-06/msg00070.html

Bug-Description:

When the readline `revert-all-at-newline' option is set, pressing newline
when the current line is one retrieved from history results in a double free
and a segmentation fault.

Patch (apply with `patch -p0'):

*** ../bash-4.3-patched/lib/readline/misc.c	2012-09-01 18:03:11.000000000 -0400
--- lib/readline/misc.c	2014-06-30 13:41:19.000000000 -0400
***************
*** 462,465 ****
--- 462,466 ----
  	  /* Set up rl_line_buffer and other variables from history entry */
  	  rl_replace_from_history (entry, 0);	/* entry->line is now current */
+ 	  entry->data = 0;			/* entry->data is now current undo list */
  	  /* Undo all changes to this history entry */
  	  while (rl_undo_list)
***************
*** 469,473 ****
  	  FREE (entry->line);
  	  entry->line = savestring (rl_line_buffer);
- 	  entry->data = 0;
  	}
        entry = previous_history ();
--- 470,473 ----

*** ../bash-4.3/patchlevel.h	2012-12-29 10:47:57.000000000 -0500
--- patchlevel.h	2014-03-20 20:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 20
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 21
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.3
Patch-ID:	bash43-022

Bug-Reported-by:	scorp.dev.null@gmail.com
Bug-Reference-ID:	<E1WxXw8-0007iE-Bi@pcm14>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2014-06/msg00061.html

Bug-Description:

Using nested pipelines within loops with the `lastpipe' option set can result
in a segmentation fault.

Patch (apply with `patch -p0'):

*** ../bash-4.3-patched/execute_cmd.c	2014-01-31 10:54:52.000000000 -0500
--- execute_cmd.c	2014-06-19 08:05:49.000000000 -0400
***************
*** 2410,2414 ****
        lstdin = wait_for (lastpid);
  #if defined (JOB_CONTROL)
!       exec_result = job_exit_status (lastpipe_jid);
  #endif
        unfreeze_jobs_list ();
--- 2425,2438 ----
        lstdin = wait_for (lastpid);
  #if defined (JOB_CONTROL)
!       /* If wait_for removes the job from the jobs table, use result of last
! 	 command as pipeline's exit status as usual.  The jobs list can get
! 	 frozen and unfrozen at inconvenient times if there are multiple pipelines
! 	 running simultaneously. */
!       if (INVALID_JOB (lastpipe_jid) == 0)
! 	exec_result = job_exit_status (lastpipe_jid);
!       else if (pipefail_opt)
! 	exec_result = exec_result | lstdin;	/* XXX */
!       /* otherwise we use exec_result */
!         
  #endif
        unfreeze_jobs_list ();
*** ../bash-4.3/patchlevel.h	2012-12-29 10:47:57.000000000 -0500
--- patchlevel.h	2014-03-20 20:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 21
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 22
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.3
Patch-ID:	bash43-023

Bug-Reported-by:	Tim Friske <me@timfriske.com>
Bug-Reference-ID:	<CAM1RzOcOR9zzC2i+aeES6LtbHNHoOV+0pZEYPrqxv_QAii-RXA@mail.gmail.com>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2014-06/msg00056.html

Bug-Description:

Bash does not correctly parse process substitution constructs that contain
unbalanced parentheses as part of the contained command.

Patch (apply with `patch -p0'):

*** ../bash-4.3-patched/subst.h	2014-01-11 21:02:27.000000000 -0500
--- subst.h	2014-07-20 17:25:01.000000000 -0400
***************
*** 83,87 ****
     Start extracting at (SINDEX) as if we had just seen "<(".
     Make (SINDEX) get the position just after the matching ")". */
! extern char *extract_process_subst __P((char *, char *, int *));
  #endif /* PROCESS_SUBSTITUTION */
  
--- 83,87 ----
     Start extracting at (SINDEX) as if we had just seen "<(".
     Make (SINDEX) get the position just after the matching ")". */
! extern char *extract_process_subst __P((char *, char *, int *, int));
  #endif /* PROCESS_SUBSTITUTION */
  
*** ../bash-4.3-patched/subst.c	2014-05-15 08:26:45.000000000 -0400
--- subst.c	2014-07-20 17:26:44.000000000 -0400
***************
*** 1193,1202 ****
     Make (SINDEX) get the position of the matching ")". */ /*))*/
  char *
! extract_process_subst (string, starter, sindex)
       char *string;
       char *starter;
       int *sindex;
  {
    return (extract_delimited_string (string, sindex, starter, "(", ")", SX_COMMAND));
  }
  #endif /* PROCESS_SUBSTITUTION */
--- 1193,1208 ----
     Make (SINDEX) get the position of the matching ")". */ /*))*/
  char *
! extract_process_subst (string, starter, sindex, xflags)
       char *string;
       char *starter;
       int *sindex;
+      int xflags;
  {
+ #if 0
    return (extract_delimited_string (string, sindex, starter, "(", ")", SX_COMMAND));
+ #else
+   xflags |= (no_longjmp_on_fatal_error ? SX_NOLONGJMP : 0);
+   return (xparse_dolparen (string, string+*sindex, sindex, xflags));
+ #endif
  }
  #endif /* PROCESS_SUBSTITUTION */
***************
*** 1786,1790 ****
  	  if (string[si] == '\0')
  	    CQ_RETURN(si);
! 	  temp = extract_process_subst (string, (c == '<') ? "<(" : ">(", &si);
  	  free (temp);		/* no SX_ALLOC here */
  	  i = si;
--- 1792,1796 ----
  	  if (string[si] == '\0')
  	    CQ_RETURN(si);
! 	  temp = extract_process_subst (string, (c == '<') ? "<(" : ">(", &si, 0);
  	  free (temp);		/* no SX_ALLOC here */
  	  i = si;
***************
*** 8250,8254 ****
  	      t_index = sindex + 1; /* skip past both '<' and LPAREN */
  
! 	    temp1 = extract_process_subst (string, (c == '<') ? "<(" : ">(", &t_index); /*))*/
  	    sindex = t_index;
  
--- 8256,8260 ----
  	      t_index = sindex + 1; /* skip past both '<' and LPAREN */
  
! 	    temp1 = extract_process_subst (string, (c == '<') ? "<(" : ">(", &t_index, 0); /*))*/
  	    sindex = t_index;
  
*** ../bash-4.3/patchlevel.h	2012-12-29 10:47:57.000000000 -0500
--- patchlevel.h	2014-03-20 20:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 22
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 23
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.3
Patch-ID:	bash43-024

Bug-Reported-by:	Corentin Peuvrel <cpeuvrel@pom-monitoring.com>
Bug-Reference-ID:	<53CE9E5D.6050203@pom-monitoring.com>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2014-07/msg00021.html

Bug-Description:

Indirect variable references do not work correctly if the reference
variable expands to an array reference using a subscript other than 0
(e.g., foo='bar[1]' ; echo ${!foo}).

Patch (apply with `patch -p0'):

*** ../bash-4.3-patched/subst.c	2014-06-03 09:32:44.000000000 -0400
--- subst.c	2014-07-23 09:58:19.000000000 -0400
***************
*** 7375,7379 ****
  
    if (want_indir)
!     tdesc = parameter_brace_expand_indir (name + 1, var_is_special, quoted, quoted_dollar_atp, contains_dollar_at);
    else
      tdesc = parameter_brace_expand_word (name, var_is_special, quoted, PF_IGNUNBOUND|(pflags&(PF_NOSPLIT2|PF_ASSIGNRHS)), &ind);
--- 7445,7455 ----
  
    if (want_indir)
!     {
!       tdesc = parameter_brace_expand_indir (name + 1, var_is_special, quoted, quoted_dollar_atp, contains_dollar_at);
!       /* Turn off the W_ARRAYIND flag because there is no way for this function
! 	 to return the index we're supposed to be using. */
!       if (tdesc && tdesc->flags)
! 	tdesc->flags &= ~W_ARRAYIND;
!     }
    else
      tdesc = parameter_brace_expand_word (name, var_is_special, quoted, PF_IGNUNBOUND|(pflags&(PF_NOSPLIT2|PF_ASSIGNRHS)), &ind);
*** ../bash-4.3/patchlevel.h	2012-12-29 10:47:57.000000000 -0500
--- patchlevel.h	2014-03-20 20:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 23
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 24
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.3
Patch-ID:	bash43-025

Bug-Reported-by:	Stephane Chazelas <stephane.chazelas@gmail.com>
Bug-Reference-ID:
Bug-Reference-URL:

Bug-Description:

Under certain circumstances, bash will execute user code while processing the
environment for exported function definitions.

Patch (apply with `patch -p0'):

*** ../bash-4.3-patched/builtins/common.h	2013-07-08 16:54:47.000000000 -0400
--- builtins/common.h	2014-09-12 14:25:47.000000000 -0400
***************
*** 34,37 ****
--- 49,54 ----
  #define SEVAL_PARSEONLY	0x020
  #define SEVAL_NOLONGJMP 0x040
+ #define SEVAL_FUNCDEF	0x080		/* only allow function definitions */
+ #define SEVAL_ONECMD	0x100		/* only allow a single command */
  
  /* Flags for describe_command, shared between type.def and command.def */
*** ../bash-4.3-patched/builtins/evalstring.c	2014-02-11 09:42:10.000000000 -0500
--- builtins/evalstring.c	2014-09-14 14:15:13.000000000 -0400
***************
*** 309,312 ****
--- 313,324 ----
  	      struct fd_bitmap *bitmap;
  
+ 	      if ((flags & SEVAL_FUNCDEF) && command->type != cm_function_def)
+ 		{
+ 		  internal_warning ("%s: ignoring function definition attempt", from_file);
+ 		  should_jump_to_top_level = 0;
+ 		  last_result = last_command_exit_value = EX_BADUSAGE;
+ 		  break;
+ 		}
+ 
  	      bitmap = new_fd_bitmap (FD_BITMAP_SIZE);
  	      begin_unwind_frame ("pe_dispose");
***************
*** 369,372 ****
--- 381,387 ----
  	      dispose_fd_bitmap (bitmap);
  	      discard_unwind_frame ("pe_dispose");
+ 
+ 	      if (flags & SEVAL_ONECMD)
+ 		break;
  	    }
  	}
*** ../bash-4.3-patched/variables.c	2014-05-15 08:26:50.000000000 -0400
--- variables.c	2014-09-14 14:23:35.000000000 -0400
***************
*** 359,369 ****
  	  strcpy (temp_string + char_index + 1, string);
  
! 	  if (posixly_correct == 0 || legal_identifier (name))
! 	    parse_and_execute (temp_string, name, SEVAL_NONINT|SEVAL_NOHIST);
! 
! 	  /* Ancient backwards compatibility.  Old versions of bash exported
! 	     functions like name()=() {...} */
! 	  if (name[char_index - 1] == ')' && name[char_index - 2] == '(')
! 	    name[char_index - 2] = '\0';
  
  	  if (temp_var = find_function (name))
--- 364,372 ----
  	  strcpy (temp_string + char_index + 1, string);
  
! 	  /* Don't import function names that are invalid identifiers from the
! 	     environment, though we still allow them to be defined as shell
! 	     variables. */
! 	  if (legal_identifier (name))
! 	    parse_and_execute (temp_string, name, SEVAL_NONINT|SEVAL_NOHIST|SEVAL_FUNCDEF|SEVAL_ONECMD);
  
  	  if (temp_var = find_function (name))
***************
*** 382,389 ****
  	      report_error (_("error importing function definition for `%s'"), name);
  	    }
- 
- 	  /* ( */
- 	  if (name[char_index - 1] == ')' && name[char_index - 2] == '\0')
- 	    name[char_index - 2] = '(';		/* ) */
  	}
  #if defined (ARRAY_VARS)
--- 385,388 ----
*** ../bash-4.3-patched/subst.c	2014-08-11 11:16:35.000000000 -0400
--- subst.c	2014-09-12 15:31:04.000000000 -0400
***************
*** 8048,8052 ****
  	  goto return0;
  	}
!       else if (var = find_variable_last_nameref (temp1))
  	{
  	  temp = nameref_cell (var);
--- 8118,8124 ----
  	  goto return0;
  	}
!       else if (var && (invisible_p (var) || var_isset (var) == 0))
! 	temp = (char *)NULL;
!       else if ((var = find_variable_last_nameref (temp1)) && var_isset (var) && invisible_p (var) == 0)
  	{
  	  temp = nameref_cell (var);
*** ../bash-4.3/patchlevel.h	2012-12-29 10:47:57.000000000 -0500
--- patchlevel.h	2014-03-20 20:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 24
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 25
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.3
Patch-ID:	bash43-026

Bug-Reported-by:	Tavis Ormandy <taviso@cmpxchg8b.com>
Bug-Reference-ID:
Bug-Reference-URL:	http://twitter.com/taviso/statuses/514887394294652929

Bug-Description:

Under certain circumstances, bash can incorrectly save a lookahead character and
return it on a subsequent call, even when reading a new line.

Patch (apply with `patch -p0'):

*** ../bash-4.3.25/parse.y	2014-07-30 10:14:31.000000000 -0400
--- parse.y	2014-09-25 20:20:21.000000000 -0400
***************
*** 2954,2957 ****
--- 2954,2959 ----
    word_desc_to_read = (WORD_DESC *)NULL;
  
+   eol_ungetc_lookahead = 0;
+ 
    current_token = '\n';		/* XXX */
    last_read_token = '\n';
*** ../bash-4.3.25/y.tab.c	2014-07-30 10:14:32.000000000 -0400
--- y.tab.c	2014-09-25 20:21:48.000000000 -0400
***************
*** 5266,5269 ****
--- 5266,5271 ----
    word_desc_to_read = (WORD_DESC *)NULL;
  
+   eol_ungetc_lookahead = 0;
+ 
    current_token = '\n';		/* XXX */
    last_read_token = '\n';
***************
*** 8540,8542 ****
  }
  #endif /* HANDLE_MULTIBYTE */
- 
--- 8542,8543 ----
*** ../bash-4.3/patchlevel.h	2012-12-29 10:47:57.000000000 -0500
--- patchlevel.h	2014-03-20 20:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 25
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 26
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.3
Patch-ID:	bash43-027

Bug-Reported-by:	Florian Weimer <fweimer@redhat.com>
Bug-Reference-ID:
Bug-Reference-URL:

Bug-Description:

This patch changes the encoding bash uses for exported functions to avoid
clashes with shell variables and to avoid depending only on an environment
variable's contents to determine whether or not to interpret it as a shell
function.

Patch (apply with `patch -p0'):

*** ../bash-4.3.26/variables.c	2014-09-25 23:02:18.000000000 -0400
--- variables.c	2014-09-27 20:52:04.000000000 -0400
***************
*** 84,87 ****
--- 84,92 ----
  #define ifsname(s)	((s)[0] == 'I' && (s)[1] == 'F' && (s)[2] == 'S' && (s)[3] == '\0')
  
+ #define BASHFUNC_PREFIX		"BASH_FUNC_"
+ #define BASHFUNC_PREFLEN	10	/* == strlen(BASHFUNC_PREFIX */
+ #define BASHFUNC_SUFFIX		"%%"
+ #define BASHFUNC_SUFFLEN	2	/* == strlen(BASHFUNC_SUFFIX) */
+ 
  extern char **environ;
  
***************
*** 280,284 ****
  static void dispose_temporary_env __P((sh_free_func_t *));     
  
! static inline char *mk_env_string __P((const char *, const char *));
  static char **make_env_array_from_var_list __P((SHELL_VAR **));
  static char **make_var_export_array __P((VAR_CONTEXT *));
--- 285,289 ----
  static void dispose_temporary_env __P((sh_free_func_t *));     
  
! static inline char *mk_env_string __P((const char *, const char *, int));
  static char **make_env_array_from_var_list __P((SHELL_VAR **));
  static char **make_var_export_array __P((VAR_CONTEXT *));
***************
*** 350,369 ****
        /* If exported function, define it now.  Don't import functions from
  	 the environment in privileged mode. */
!       if (privmode == 0 && read_but_dont_execute == 0 && STREQN ("() {", string, 4))
  	{
  	  string_length = strlen (string);
! 	  temp_string = (char *)xmalloc (3 + string_length + char_index);
  
! 	  strcpy (temp_string, name);
! 	  temp_string[char_index] = ' ';
! 	  strcpy (temp_string + char_index + 1, string);
  
  	  /* Don't import function names that are invalid identifiers from the
  	     environment, though we still allow them to be defined as shell
  	     variables. */
! 	  if (legal_identifier (name))
! 	    parse_and_execute (temp_string, name, SEVAL_NONINT|SEVAL_NOHIST|SEVAL_FUNCDEF|SEVAL_ONECMD);
  
! 	  if (temp_var = find_function (name))
  	    {
  	      VSETATTR (temp_var, (att_exported|att_imported));
--- 355,385 ----
        /* If exported function, define it now.  Don't import functions from
  	 the environment in privileged mode. */
!       if (privmode == 0 && read_but_dont_execute == 0 && 
!           STREQN (BASHFUNC_PREFIX, name, BASHFUNC_PREFLEN) &&
!           STREQ (BASHFUNC_SUFFIX, name + char_index - BASHFUNC_SUFFLEN) &&
! 	  STREQN ("() {", string, 4))
  	{
+ 	  size_t namelen;
+ 	  char *tname;		/* desired imported function name */
+ 
+ 	  namelen = char_index - BASHFUNC_PREFLEN - BASHFUNC_SUFFLEN;
+ 
+ 	  tname = name + BASHFUNC_PREFLEN;	/* start of func name */
+ 	  tname[namelen] = '\0';		/* now tname == func name */
+ 
  	  string_length = strlen (string);
! 	  temp_string = (char *)xmalloc (namelen + string_length + 2);
  
! 	  memcpy (temp_string, tname, namelen);
! 	  temp_string[namelen] = ' ';
! 	  memcpy (temp_string + namelen + 1, string, string_length + 1);
  
  	  /* Don't import function names that are invalid identifiers from the
  	     environment, though we still allow them to be defined as shell
  	     variables. */
! 	  if (absolute_program (tname) == 0 && (posixly_correct == 0 || legal_identifier (tname)))
! 	    parse_and_execute (temp_string, tname, SEVAL_NONINT|SEVAL_NOHIST|SEVAL_FUNCDEF|SEVAL_ONECMD);
  
! 	  if (temp_var = find_function (tname))
  	    {
  	      VSETATTR (temp_var, (att_exported|att_imported));
***************
*** 378,383 ****
  		}
  	      last_command_exit_value = 1;
! 	      report_error (_("error importing function definition for `%s'"), name);
  	    }
  	}
  #if defined (ARRAY_VARS)
--- 394,402 ----
  		}
  	      last_command_exit_value = 1;
! 	      report_error (_("error importing function definition for `%s'"), tname);
  	    }
+ 
+ 	  /* Restore original suffix */
+ 	  tname[namelen] = BASHFUNC_SUFFIX[0];
  	}
  #if defined (ARRAY_VARS)
***************
*** 2955,2959 ****
  
    INVALIDATE_EXPORTSTR (var);
!   var->exportstr = mk_env_string (name, value);
  
    array_needs_making = 1;
--- 2974,2978 ----
  
    INVALIDATE_EXPORTSTR (var);
!   var->exportstr = mk_env_string (name, value, 0);
  
    array_needs_making = 1;
***************
*** 3853,3871 ****
  
  static inline char *
! mk_env_string (name, value)
       const char *name, *value;
  {
!   int name_len, value_len;
!   char	*p;
  
    name_len = strlen (name);
    value_len = STRLEN (value);
!   p = (char *)xmalloc (2 + name_len + value_len);
!   strcpy (p, name);
!   p[name_len] = '=';
    if (value && *value)
!     strcpy (p + name_len + 1, value);
    else
!     p[name_len + 1] = '\0';
    return (p);
  }
--- 3872,3911 ----
  
  static inline char *
! mk_env_string (name, value, isfunc)
       const char *name, *value;
+      int isfunc;
  {
!   size_t name_len, value_len;
!   char	*p, *q;
  
    name_len = strlen (name);
    value_len = STRLEN (value);
! 
!   /* If we are exporting a shell function, construct the encoded function
!      name. */
!   if (isfunc && value)
!     {
!       p = (char *)xmalloc (BASHFUNC_PREFLEN + name_len + BASHFUNC_SUFFLEN + value_len + 2);
!       q = p;
!       memcpy (q, BASHFUNC_PREFIX, BASHFUNC_PREFLEN);
!       q += BASHFUNC_PREFLEN;
!       memcpy (q, name, name_len);
!       q += name_len;
!       memcpy (q, BASHFUNC_SUFFIX, BASHFUNC_SUFFLEN);
!       q += BASHFUNC_SUFFLEN;
!     }
!   else
!     {
!       p = (char *)xmalloc (2 + name_len + value_len);
!       memcpy (p, name, name_len);
!       q = p + name_len;
!     }
! 
!   q[0] = '=';
    if (value && *value)
!     memcpy (q + 1, value, value_len + 1);
    else
!     q[1] = '\0';
! 
    return (p);
  }
***************
*** 3953,3957 ****
  	     using the cached exportstr... */
  	  list[list_index] = USE_EXPORTSTR ? savestring (value)
! 					   : mk_env_string (var->name, value);
  
  	  if (USE_EXPORTSTR == 0)
--- 3993,3997 ----
  	     using the cached exportstr... */
  	  list[list_index] = USE_EXPORTSTR ? savestring (value)
! 					   : mk_env_string (var->name, value, function_p (var));
  
  	  if (USE_EXPORTSTR == 0)
*** ../bash-4.3/patchlevel.h	2012-12-29 10:47:57.000000000 -0500
--- patchlevel.h	2014-03-20 20:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 26
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 27
  
  #endif /* _PATCHLEVEL_H_ */
